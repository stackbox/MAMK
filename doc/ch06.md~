寻访x86处理器“实模式”和“保护模式”的前世今生 
===

转载自：http://blog.chinaunix.net/uid-23069658-id-3569341.html

还是把博文“CPU的内部架构和工作原理”里的这个表搬出来，祭奠那些不应该在岁月的洪荒中被淹埋的荣耀：

![cpu history](img/ch06-01.jpg)

8086的诞生，标志着Intel 正式进入了x86时代，这是个多么具有纪念意义的日子：1978-6-8。同时，8086的诞生也是处理器内存寻址技术的第一次飞跃。
对于一根实际的、实实在在的、物理的、可看得见、摸得着的内存条而言，处理器把它当做8位一个字节的序列来管理和存取，每一个内存字节都有一个对应的地址，我们叫它物理地址，用地址可以表示的长度叫做寻址空间。而CPU是如何去访问内存单元里的数据的方式就叫做寻址。
8086得CPU在内存寻址方面第一次引入了一个非常重要的概念----段。在8086之前都是4位机和8位机的天下，那是并没有段的概念。当程序要访问内存时都是要给出内存的实际物理地址，这样在程序源代码中就会出现很多硬编码的物理地址。这样的程序可想而知，难重定位，可控性弱，结构丑陋，那个年代写这样的程序在我们现在看来是多么让人恼火的一件事儿。
8080问世后四年也就是1978年，Intel开始设计16位CPU，正常来说8086的寻址空间应该是216=64KB才对，但Intel就偏偏不这干，8086的目标寻址空间直指1M，也就是说8086的地址总线位宽要达到20位。如何让16位的内部寄存器对20位的外部地址空间进行寻址，Intel的工程师们从当时的PDP-11小型机身上找到了灵感。PDP-11是美国迪吉多电脑(Digital Equipment Corp.)公司于1970到1980年代热销的16位迷你电脑，PDP-11的内存管理单元(MMU)可以将16位地址映射到24位地址空间里(至于人家是怎么弄，我就真不晓得了)。
为了支持分段机制，Intel在8086的CPU里新增了4个寄存器，分别是代码段CS，数据段DS，堆栈段SS和其他ES(以后深入介绍一下这几个兄弟伙，这涉及到进程的在内存的运行情况)。这样一来，一个物理地址就由两个部分组成，分别是“段地址”:“段内偏移量”。例如，ES=0x1000，DI=0xFFFF，那么这个数据ES:DI在内存里的绝对物理地址就是：
AD(Absolute Address)=(ES)*(0x10)+(DI)=0x1FFFF
就是讲段基地址左移4位然后加上段内偏移量就得到了物理内存里的绝对地址，经过这么一个变换，就可以得到一个20位的地址，8086就可以对20位的1M内存空间进行寻址了。如下：

![absolute address](ch06-02.jpg)

很明显，这种方式可以寻址的最高地址为0xFFFF:0xFFFF，其地址空间为0x00000~0x10FFEF，因为8086的地址总线是20位，最大只能访问到1MB的物理地址空间，即物理地址空间是0x00000~0xFFFFF。当程序访问0x100000~0x10FFEF这一段地址时，因为其逻辑上是正常的，CPU并不会认为其访问越界而产生异常，但这段地址确实没有实际的物理地址与其对应，怎么办？此时CPU采取的策略是，对于这部分超出1M地址空间的部分，自动将其从物理0地址处开始映射。也就是说，系统计算实际物理地址时是按照对1M求模运算的方式进行的，在有些技术文献里你会看到这种技术被称之为wrap-around。还是通过一幅图来描述一下吧：

![wrap around](img/ch06-03.jpg)
